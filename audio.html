<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Roboto&family=Open+Sans&family=Lato&family=Montserrat&family=Poppins&display=swap" rel="stylesheet">
    <title>AUDIO SPRECTRUM Cr.</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <meta property="og:title" content="AUDIO SPECTRUM Cr.">
    <meta property="og:description" content="Create proffessional audio spectrum's in easy fast and efficient way.">
    <meta property="og:image" content="https://i.ibb.co/5hNwtF5W/AUDIO.png">
    <meta property="og:url" content="https://www.yoursite.com/your-page">
    <meta property="og:type" content="SPECTRUM CREATOR">
    
    <style>
        /* General Styles */
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            color: #333;
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 250px;
            background: #fff;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            overflow-y: auto; /* Allow vertical scrolling */
            height: 100vh; /* Full height */
        }

        .sidebar h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #0073b1;
        }

        .sidebar label {
            display: block;
            margin: 10px 0 5px;
            font-weight: bold;
        }

        .sidebar input[type="color"],
        .sidebar select,
        .sidebar button,
        .sidebar input[type="text"],
        .sidebar input[type="file"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }

        .sidebar button {
            background: #0073b1;
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .sidebar button:hover {
            background: #005f8a;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .main-content h1 {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #0073b1;
        }

        canvas {
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        /* Controls */
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        .controls button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #0073b1;
            color: white;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .controls button:hover {
            background: #005f8a;
        }

        .controls button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Download Link */
        #downloadLink {
            margin-top: 20px;
            padding: 10px 20px;
            background: #0073b1;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            display: none;
        }

        #downloadLink:hover {
            background: #005f8a;
        }

        /* New Download Audio Link */
        #downloadAudioLink {
            margin-top: 20px;
            padding: 10px 20px;
            background: #0073b1;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            display: none;
        }

        #downloadAudioLink:hover {
            background: #005f8a;
        }
    </style>
</head>
<body>
    <!-- Sidebar -->
    <div class="sidebar">
        <button onclick="window.location.href='index.html';" style="background-color: rgb(0, 110, 255); color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">
            BACK
        </button>
                <h2>Settings</h2>

       <!-- Bar Layout -->
<label for="barLayout">Bar Layout</label>
<select id="barLayout">
    <option value="linear">Linear (Horizontal)</option>
    <option value="vertical">Linear (Vertical)</option>
    <option value="circular">Circular</option>
    <option value="circularGradientOutward">Circular Gradient Outward</option>
    <option value="center">Center Bars</option>
    <option value="radial">Radial</option>
    <option value="logarithmic">Logarithmic</option>
    <option value="gradient">Gradient</option>
    <option value="discrete">Discrete</option>
    <option value="waveform">Waveform</option>
    <option value="branching">Branching</option>
</select>

        <!-- Bar Color -->
        <label for="barColor">Bar Color</label>
        <input type="color" id="barColor" value="#6e44ff">

        <!-- Particle Position -->
<label for="particlePosition">Particle Position</label>
<select id="particlePosition">
    <option value="rightToLeft">Right to Left</option>
    <option value="leftToRight">Left to Right</option>
    <option value="upToDown">Up to Down</option>
    <option value="downToUp">Down to Up</option>
    <option value="center">Center Outward</option>
    <option value="full">Full Screen</option>
</select>

        <!-- Particle Color -->
        <label for="particleColor">Particle Color</label>
        <input type="color" id="particleColor" value="#ffffff">

        <!-- Particle Effects -->
        <label for="particleToggle">Enable Particles</label>
        <select id="particleToggle">
            <option value="true">Yes</option>
            <option value="false">No</option>
        </select>

        <!-- Background Image -->
        <label for="backgroundImage">Background Image</label>
        <input type="file" id="backgroundImage" accept="image/*">

        <!-- Watermark Position -->
        <label for="watermarkPosition">Watermark Position</label>
        <select id="watermarkPosition">
            <option value="upperleft">Upper Left</option>
            <option value="upperright">Upper Right</option>
            <option value="downleft">Lower Left</option>
            <option value="downright">Lower Right</option>
        </select>

        <!-- Add Text -->
        <label for="textInput">Add Text</label>
        <input type="text" id="textInput" placeholder="Enter text">

        <!-- Font Select -->
        <label for="fontSelect">Font</label>
        <select id="fontSelect">
            <option value="Calibri, sans-serif">Calibri</option>
            <option value="Comfortaa, cursive">Comfortaa</option>
            <option value="Arial, sans-serif">Arial</option>
            <option value="Times New Roman, serif">Times New Roman</option>
            <option value="Courier New, monospace">Courier New</option>
            <option value="Roboto, sans-serif">Roboto</option>
            <option value="Open Sans, sans-serif">Open Sans</option>
            <option value="Lato, sans-serif">Lato</option>
            <option value="Montserrat, sans-serif">Montserrat</option>
            <option value="Poppins, sans-serif">Poppins</option>
        </select>

        <!-- Text Color -->
        <label for="textColor">Text Color</label>
        <input type="color" id="textColor" value="#ffffff">

        <!-- Upload Logo -->
        <label for="logoUpload">Upload Logo</label>
        <input type="file" id="logoUpload" accept="image/*">

        <!-- Reset Settings -->
        <button id="resetSettings">Reset Settings</button>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <h1>AUDIO SPECTRUM Creator</h1>
        <canvas id="canvas"></canvas>

        <!-- Controls -->
        <div class="controls">
            <input type="file" id="audioFile" accept="audio/*">
            <button id="startRecording">Start Recording</button>
            <button id="stopRecording" disabled>Stop Recording</button>
        </div>

        <!-- Download Links -->
        <a id="downloadLink">Download Video</a>
        <a id="downloadAudioLink">Download Audio</a>
        <p>Made by AUTO ED | @2025 | *subscribe to remove watermark</p>
    </div>

    <script>
        const audioFileInput = document.getElementById('audioFile');
        const backgroundImageInput = document.getElementById('backgroundImage');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startRecording');
        const stopBtn = document.getElementById('stopRecording');
        const downloadLink = document.getElementById('downloadLink');
        const downloadAudioLink = document.getElementById('downloadAudioLink');
        const barLayoutSelect = document.getElementById('barLayout');
        const barColorInput = document.getElementById('barColor');
        const particleColorInput = document.getElementById('particleColor');
        const particleToggleSelect = document.getElementById('particleToggle');
        const particlePositionSelect = document.getElementById('particlePosition');
        const resetSettingsBtn = document.getElementById('resetSettings');
        const textInput = document.getElementById('textInput');
        const fontSelect = document.getElementById('fontSelect');
        const textColorInput = document.getElementById('textColor');
        const logoUpload = document.getElementById('logoUpload');
        const watermarkPositionSelect = document.getElementById('watermarkPosition');
    
        // Canvas setup
        const displayWidth = 800;
        const displayHeight = 400;
        canvas.width = displayWidth;
        canvas.height = displayHeight;
    
        // Off-screen canvas for recording
        const offScreenCanvas = document.createElement('canvas');
        const offScreenCtx = offScreenCanvas.getContext('2d');
        let selectedQuality = '720';
        let recordingWidth = 1280;
        let recordingHeight = 720;
        offScreenCanvas.width = recordingWidth;
        offScreenCanvas.height = recordingHeight;
    
        // Audio and visualization variables
        let audioContext, analyser, source, dataArray, recorder, chunks = [];
        let backgroundImage = null;
        let particles = [];
        let barLayout = 'linear';
        let barColor = '#6e44ff';
        let particleColor = '#ffffff';
        let enableParticles = true;
        let particlePosition = 'rightToLeft';
        let customText = '';
        let customFont = 'Calibri, sans-serif';
        let customTextColor = '#ffffff';
        let logoImage = null;
        let watermarkPosition = 'upperleft';
        let audioBlob = null;
        let audioElement = null;
        let lastFrameTime = 0;
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;
        const MAX_PARTICLES = 50;
    
        // Watermark animation
        const watermarkCycleDuration = 10 * 1000;
        let watermarkStartTime = null;
    
        // Shake variables with smoothing
        let shakeX = 0;
        let shakeY = 0;
        let lastShakeIntensity = 0;
        const SHAKE_SMOOTHING_FACTOR = 0.3; // Controls how quickly shake adapts
    
        // Cached background canvases
        const backgroundCanvas = document.createElement('canvas');
        backgroundCanvas.width = displayWidth;
        backgroundCanvas.height = displayHeight;
        const backgroundCtx = backgroundCanvas.getContext('2d');
        const offScreenBackgroundCanvas = document.createElement('canvas');
        offScreenBackgroundCanvas.width = recordingWidth;
        offScreenBackgroundCanvas.height = recordingHeight;
        const offScreenBackgroundCtx = offScreenBackgroundCanvas.getContext('2d');
    
        // Event Listeners for Settings
        barLayoutSelect.addEventListener('change', (e) => { barLayout = e.target.value; });
        barColorInput.addEventListener('input', (e) => { barColor = e.target.value; });
        particleColorInput.addEventListener('input', (e) => { particleColor = e.target.value; });
        particleToggleSelect.addEventListener('change', (e) => { enableParticles = e.target.value === 'true'; });
        particlePositionSelect.addEventListener('change', (e) => { particlePosition = e.target.value; });
        textInput.addEventListener('input', (e) => { customText = e.target.value; });
        fontSelect.addEventListener('change', (e) => { customFont = e.target.value; });
        textColorInput.addEventListener('input', (e) => { customTextColor = e.target.value; });
        logoUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => { logoImage = img; };
                };
                reader.readAsDataURL(file);
            }
        });
        watermarkPositionSelect.addEventListener('change', (e) => { watermarkPosition = e.target.value; });
        resetSettingsBtn.addEventListener('click', resetSettings);
    
        function resetSettings() {
            barLayoutSelect.value = 'linear';
            barColorInput.value = '#6e44ff';
            particleColorInput.value = '#ffffff';
            particleToggleSelect.value = 'true';
            particlePositionSelect.value = 'rightToLeft';
            textInput.value = '';
            fontSelect.value = 'Calibri, sans-serif';
            textColorInput.value = '#ffffff';
            logoUpload.value = '';
            watermarkPositionSelect.value = 'upperleft';
            barLayout = 'linear';
            barColor = '#6e44ff';
            particleColor = '#ffffff';
            enableParticles = true;
            particlePosition = 'rightToLeft';
            customText = '';
            customFont = 'Calibri, sans-serif';
            customTextColor = '#ffffff';
            logoImage = null;
            watermarkPosition = 'upperleft';
        }
    
        // Background Image Upload
        backgroundImageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        backgroundImage = img;
                        backgroundCtx.drawImage(img, 0, 0, displayWidth, displayHeight);
                        offScreenBackgroundCtx.drawImage(img, 0, 0, recordingWidth, recordingHeight);
                        updateVignette(backgroundCtx, displayWidth, displayHeight, 0.2);
                        updateVignette(offScreenBackgroundCtx, recordingWidth, recordingHeight, 0.2);
                    };
                };
                reader.readAsDataURL(file);
            }
        });
    
        function prepareAudioDownloadLink(file) {
            const audioURL = URL.createObjectURL(file);
            downloadAudioLink.href = audioURL;
            downloadAudioLink.download = 'audio_file.mp3';
            downloadAudioLink.style.display = 'block';
        }
    
        function setupAudioContext(audio) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            analyser.smoothingTimeConstant = 0.8;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            source = audioContext.createMediaElementSource(audio);
            source.connect(analyser);
            analyser.connect(audioContext.destination);
            watermarkStartTime = performance.now();
            drawVisualizer();
        }
    
        // Realistic Vignette with Dynamic Intensity and Blur
        function updateVignette(context, width, height, baseIntensity) {
            let freqSum = 0;
            for (let i = 0; i < dataArray.length; i += 10) {
                freqSum += dataArray[i];
            }
            const audioIntensity = Math.min(0.8, (freqSum / (dataArray.length / 10 * 255)) * 2);
            const dynamicIntensity = baseIntensity + (audioIntensity * 0.6);
    
            const gradient = context.createRadialGradient(
                width / 2, height / 2, 0,
                width / 2, height / 2, Math.max(width, height) / 1.5
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(0.7, 'rgba(30, 30, 30, 0.2)');
            gradient.addColorStop(1, `rgba(0, 0, 0, ${dynamicIntensity})`);
    
            context.save();
            context.filter = 'blur(10px)';
            context.globalCompositeOperation = 'multiply';
            context.fillStyle = gradient;
            context.fillRect(0, 0, width, height);
            context.restore();
            context.filter = 'none';
        }
    
        // Main Visualization Loop with Music-Driven Shake
        function drawVisualizer(timestamp) {
            if (!timestamp) timestamp = performance.now();
            if (timestamp - lastFrameTime < frameInterval) {
                requestAnimationFrame(drawVisualizer);
                return;
            }
            lastFrameTime = timestamp;
    
            analyser.getByteFrequencyData(dataArray);
    
            // Calculate bass intensity (lower frequencies for shake)
            const bassEnd = Math.floor(dataArray.length * 0.25);
            let bassSum = 0;
            for (let i = 0; i < bassEnd; i++) {
                bassSum += dataArray[i];
            }
            const rawBassIntensity = bassSum / (bassEnd * 255);
    
            // Calculate mid-range intensity for direction variation
            const midStart = Math.floor(dataArray.length * 0.25);
            const midEnd = Math.floor(dataArray.length * 0.75);
            let midSum = 0;
            for (let i = midStart; i < midEnd; i++) {
                midSum += dataArray[i];
            }
            const midIntensity = midSum / ((midEnd - midStart) * 255);
    
            // Smooth shake intensity with exponential moving average
            const currentShakeIntensity = Math.min(10, rawBassIntensity * 20); // Amplify for visibility
            lastShakeIntensity = (lastShakeIntensity * (1 - SHAKE_SMOOTHING_FACTOR)) + (currentShakeIntensity * SHAKE_SMOOTHING_FACTOR);
    
            // Dynamic shake direction based on mid-range frequencies
            const angleOffset = (midIntensity * 2 - 1) * Math.PI / 4; // Range: -45° to +45°
            const shakeMagnitude = lastShakeIntensity;
            shakeX = Math.cos(angleOffset) * shakeMagnitude * (Math.random() * 0.5 + 0.5);
            shakeY = Math.sin(angleOffset) * shakeMagnitude * (Math.random() * 0.5 + 0.5);
    
            ctx.clearRect(0, 0, displayWidth, displayHeight);
            offScreenCtx.clearRect(0, 0, recordingWidth, recordingHeight);
    
            // Apply shake transformation
            ctx.save();
            offScreenCtx.save();
            ctx.translate(shakeX, shakeY);
            offScreenCtx.translate(shakeX * (recordingWidth / displayWidth), 
                                 shakeY * (recordingHeight / displayHeight));
    
            if (backgroundImage) {
                ctx.drawImage(backgroundCanvas, 0, 0);
                offScreenCtx.drawImage(offScreenBackgroundCanvas, 0, 0);
            } else {
                ctx.fillStyle = '#222831';
                ctx.fillRect(0, 0, displayWidth, displayHeight);
                offScreenCtx.fillStyle = '#222831';
                offScreenCtx.fillRect(0, 0, recordingWidth, recordingHeight);
            }
    
            ctx.imageSmoothingEnabled = true;
            offScreenCtx.imageSmoothingEnabled = true;
    
            const drawFunc = {
                'linear': drawLinearBars,
                'vertical': drawVerticalBars,
                'circular': drawCircularBars,
                'center': drawCenterBars,
                'radial': drawRadialBars,
                'logarithmic': drawLogarithmicBars,
                'gradient': drawGradientBars,
                'discrete': drawDiscreteBars,
                'waveform': drawWaveformBars,
                'branching': drawBranchingBars,
                'circularGradientOutward': drawCircularGradientOutward
            }[barLayout];
            drawFunc(ctx, displayWidth, displayHeight);
            drawFunc(offScreenCtx, recordingWidth, recordingHeight);
    
            if (enableParticles) {
                drawParticles(ctx, displayWidth, displayHeight);
                drawParticles(offScreenCtx, recordingWidth, recordingHeight);
            }
    
            drawCustomTextAndLogo(ctx, displayWidth, displayHeight);
            drawCustomTextAndLogo(offScreenCtx, recordingWidth, recordingHeight);
    
            drawWatermark(ctx, displayWidth, displayHeight, timestamp);
            drawWatermark(offScreenCtx, recordingWidth, recordingHeight, timestamp);
    
            updateVignette(ctx, displayWidth, displayHeight, 0.2);
            updateVignette(offScreenCtx, recordingWidth, recordingHeight, 0.2);
    
            ctx.restore();
            offScreenCtx.restore();
    
            requestAnimationFrame(drawVisualizer);
        }
    
        // Simplified Spectrum Visualizations
        function drawLinearBars(context, width, height) {
            const barWidth = width / dataArray.length * 2;
            let x = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height * 0.9;
                context.fillStyle = barColor;
                context.fillRect(x, height - barHeight, barWidth - 2, barHeight);
                x += barWidth;
            }
        }
    
        function drawVerticalBars(context, width, height) {
            const barHeight = height / dataArray.length * 2;
            let y = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const barWidth = (dataArray[i] / 255) * width * 0.5;
                context.fillStyle = barColor;
                context.fillRect(width - barWidth, y, barWidth, barHeight - 2);
                y += barHeight;
            }
        }
    
        function drawCircularBars(context, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 3;
            const angleStep = (Math.PI * 2) / dataArray.length;
            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * 80;
                const angle = i * angleStep;
                const x1 = centerX + Math.cos(angle) * radius;
                const y1 = centerY + Math.sin(angle) * radius;
                const x2 = centerX + Math.cos(angle) * (radius + barHeight);
                const y2 = centerY + Math.sin(angle) * (radius + barHeight);
                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.strokeStyle = barColor;
                context.lineWidth = 2;
                context.stroke();
            }
        }
    
        function drawCenterBars(context, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const barWidth = width / dataArray.length * 2;
            let x = centerX - (dataArray.length * barWidth) / 2;
            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height * 0.7;
                context.fillStyle = barColor;
                context.fillRect(x, centerY - barHeight / 2, barWidth - 2, barHeight);
                x += barWidth;
            }
        }
    
        function drawRadialBars(context, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) / 2;
            const angleStep = (Math.PI * 2) / dataArray.length;
            for (let i = 0; i < dataArray.length; i++) {
                const radius = (dataArray[i] / 255) * maxRadius;
                const angle = i * angleStep;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                context.beginPath();
                context.moveTo(centerX, centerY);
                context.lineTo(x, y);
                context.strokeStyle = barColor;
                context.lineWidth = 2;
                context.stroke();
            }
        }
    
        function drawLogarithmicBars(context, width, height) {
            const barWidth = width / dataArray.length * 2;
            let x = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = Math.log1p(dataArray[i]) * 50;
                context.fillStyle = barColor;
                context.fillRect(x, height - barHeight, barWidth - 2, barHeight);
                x += barWidth;
            }
        }
    
        function drawGradientBars(context, width, height) {
            const barWidth = width / dataArray.length * 2;
            let x = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height * 0.9;
                context.fillStyle = barColor;
                context.fillRect(x, height - barHeight, barWidth - 2, barHeight);
                x += barWidth;
            }
        }
    
        function drawDiscreteBars(context, width, height) {
            const barWidth = width / dataArray.length * 2;
            let x = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = Math.floor(dataArray[i] / 51) * 51;
                context.fillStyle = barColor;
                context.fillRect(x, height - barHeight, barWidth - 2, barHeight);
                x += barWidth;
            }
        }
    
        function drawWaveformBars(context, width, height) {
            context.beginPath();
            const barWidth = width / dataArray.length;
            let x = 0;
            context.moveTo(0, height / 2);
            for (let i = 0; i < dataArray.length; i++) {
                const value = (dataArray[i] - 128) / 128 * (height / 4);
                context.lineTo(x, height / 2 + value);
                x += barWidth;
            }
            context.strokeStyle = barColor;
            context.lineWidth = 2;
            context.stroke();
        }
    
        function drawBranchingBars(context, width, height) {
            const centerX = width / 2;
            const centerY = height;
            const angleStep = Math.PI / (dataArray.length - 1);
            for (let i = 0; i < dataArray.length; i++) {
                const value = (dataArray[i] / 255) * height / 2;
                const angle = -Math.PI / 2 + i * angleStep;
                const x = centerX + Math.cos(angle) * value;
                const y = centerY + Math.sin(angle) * value;
                context.beginPath();
                context.moveTo(centerX, centerY);
                context.lineTo(x, y);
                context.strokeStyle = barColor;
                context.lineWidth = 2;
                context.stroke();
            }
        }
    
        function drawCircularGradientOutward(context, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const baseRadius = Math.min(width, height) / 4;
            const angleStep = (Math.PI * 2) / dataArray.length;
            
            context.save();
            context.translate(centerX, centerY);
    
            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * 100;
                const angle = i * angleStep;
                
                const innerRadius = baseRadius;
                const outerRadius = baseRadius + barHeight;
                
                context.beginPath();
                context.moveTo(Math.cos(angle) * innerRadius, Math.sin(angle) * innerRadius);
                context.lineTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
                context.strokeStyle = barColor;
                context.lineWidth = 2;
                context.stroke();
            }
    
            context.restore();
        }
    
        // Lightweight Particle System
        function drawParticles(context, width, height) {
            const particleCount = Math.min(5, Math.floor(dataArray.length / 50));
            for (let i = 0; i < particleCount; i++) {
                const intensity = dataArray[i * 50] / 255 || 0.1;
                if (intensity > 0.1) {
                    let x, y, velocity;
                    const speed = intensity * 3 + 0.5;
    
                    switch (particlePosition) {
                        case 'rightToLeft':
                            x = width;
                            y = (i / particleCount) * height;
                            velocity = { x: -speed, y: 0 };
                            break;
                        case 'leftToRight':
                            x = 0;
                            y = (i / particleCount) * height;
                            velocity = { x: speed, y: 0 };
                            break;
                        case 'upToDown':
                            x = (i / particleCount) * width;
                            y = 0;
                            velocity = { x: 0, y: speed };
                            break;
                        case 'downToUp':
                            x = (i / particleCount) * width;
                            y = height;
                            velocity = { x: 0, y: -speed };
                            break;
                        case 'center':
                            x = width / 2;
                            y = height / 2;
                            const angle = Math.random() * Math.PI * 2;
                            velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
                            break;
                        case 'full':
                            x = Math.random() * width;
                            y = Math.random() * height;
                            velocity = { x: (Math.random() - 0.5) * speed, y: (Math.random() - 0.5) * speed };
                            break;
                    }
    
                    particles.push(new Particle(x, y, 2, particleColor, velocity, intensity));
                }
            }
    
            particles = particles.filter(p => {
                switch (particlePosition) {
                    case 'rightToLeft': return p.x > -p.radius;
                    case 'leftToRight': return p.x < width + p.radius;
                    case 'upToDown': return p.y < height + p.radius;
                    case 'downToUp': return p.y > -p.radius;
                    case 'center': return p.x > -p.radius && p.x < width + p.radius && 
                                      p.y > -p.radius && p.y < height + p.radius;
                    case 'full': return p.x > -p.radius && p.x < width + p.radius && 
                                     p.y > -p.radius && p.y < height + p.radius;
                }
            }).slice(0, MAX_PARTICLES);
    
            particles.forEach(p => p.update(context));
        }
    
        class Particle {
            constructor(x, y, radius, color, velocity, intensity) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.velocity = velocity;
                this.alpha = 1;
                this.intensity = intensity;
            }
    
            draw(context) {
                context.save();
                context.globalAlpha = this.alpha;
                context.beginPath();
                context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                context.fillStyle = this.color;
                context.fill();
                context.restore();
            }
    
            update(context) {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha -= 0.02;
                if (this.alpha > 0) this.draw(context);
            }
        }
    
        function drawCustomTextAndLogo(context, width, height) {
            if (customText || logoImage) {
                context.save();
                context.translate(width / 2, height / 2);
                if (logoImage) {
                    const logoSize = 100;
                    context.drawImage(logoImage, -logoSize / 2, -logoSize / 2 - 50, logoSize, logoSize);
                }
                if (customText) {
                    context.font = `24px ${customFont}`;
                    context.fillStyle = customTextColor;
                    context.textAlign = 'center';
                    context.fillText(customText, 0, 30);
                }
                context.restore();
            }
        }
    
        function drawWatermark(context, width, height, timestamp) {
            const elapsed = (timestamp - watermarkStartTime) % watermarkCycleDuration;
            const progress = elapsed / watermarkCycleDuration;
            context.font = 'bold 24px "Segoe UI", Arial, sans-serif';
            const padding = 10;
            const watermarkText = 'AUTO ED';
            let x, y;
            switch (watermarkPosition) {
                case 'upperleft': x = padding; y = padding + 24; break;
                case 'upperright': x = width - context.measureText(watermarkText).width - padding; y = padding + 24; break;
                case 'downleft': x = padding; y = height - padding; break;
                case 'downright': x = width - context.measureText(watermarkText).width - padding; y = height - padding; break;
            }
            context.fillStyle = '#ffffff';
            context.fillText('AUTO', x, y);
            context.fillStyle = '#ff0000';
            context.fillText('ED', x + context.measureText('AUTO ').width, y);
    
            context.font = 'italic 40px "Segoe UI", Arial, sans-serif';
            const startX = width - context.measureText('AUTO ED').width - padding;
            const startY = padding + 40;
            const endX = padding;
            const endY = height - padding;
            const dynamicX = startX + (endX - startX) * progress;
            const dynamicY = startY + (endY - startY) * progress;
            
            context.fillStyle = 'rgba(255, 255, 255, 0.3)';
            context.fillText('AUTO', dynamicX, dynamicY);
            context.fillStyle = 'rgba(255, 0, 0, 0.3)';
            context.fillText('ED', dynamicX + context.measureText('AUTO ').width, dynamicY);
        }
    
        // Recording Resolution
        function setRecordingResolution(quality) {
            const resolutionMap = {
                '1080': { width: 1920, height: 1080 },
                '720': { width: 1280, height: 720 },
                '360': { width: 640, height: 360 },
                '240': { width: 426, height: 240 },
                '140': { width: 256, height: 144 }
            };
            const { width, height } = resolutionMap[quality] || resolutionMap['720'];
            offScreenCanvas.width = width;
            offScreenCanvas.height = height;
            offScreenBackgroundCanvas.width = width;
            offScreenBackgroundCanvas.height = height;
            recordingWidth = width;
            recordingHeight = height;
            if (backgroundImage) {
                offScreenBackgroundCtx.drawImage(backgroundImage, 0, 0, width, height);
                updateVignette(offScreenBackgroundCtx, recordingWidth, recordingHeight, 0.2);
            }
        }
    
        // Quality Popup
        function showQualityPopup(callback) {
            const popup = document.createElement('div');
            popup.id = 'qualityPopup';
            popup.innerHTML = `
                <h3>Select Video Quality</h3>
                <button data-quality="1080">1080HD</button>
                <button data-quality="720">720p</button>
                <button data-quality="360">360p</button>
                <button data-quality="240">240p</button>
                <button data-quality="140">140p</button>
            `;
            document.body.appendChild(popup);
            popup.querySelectorAll('button').forEach(button => {
                button.addEventListener('click', () => {
                    selectedQuality = button.getAttribute('data-quality');
                    setRecordingResolution(selectedQuality);
                    document.body.removeChild(popup);
                    callback();
                });
            });
        }
    
        // Recording
        startBtn.addEventListener('click', () => {
            if (!audioElement) {
                alert("Please upload an audio file first.");
                return;
            }
            showQualityPopup(() => {
                chunks = [];
                const stream = offScreenCanvas.captureStream(targetFPS);
                const audioStream = audioElement.captureStream();
                const combinedStream = new MediaStream([...stream.getVideoTracks(), ...audioStream.getAudioTracks()]);
                recorder = new MediaRecorder(combinedStream, {
                    mimeType: 'video/webm;codecs=vp9',
                    videoBitsPerSecond: 4000000,
                    audioBitsPerSecond: 128000
                });
    
                recorder.ondataavailable = (e) => chunks.push(e.data);
                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    downloadLink.href = URL.createObjectURL(blob);
                    downloadLink.download = `audio_visualization_${selectedQuality}p.webm`;
                    downloadLink.style.display = 'block';
                    chunks = [];
                };
    
                audioElement.currentTime = 0;
                audioElement.play();
                recorder.start(16);
                startBtn.disabled = true;
                stopBtn.disabled = false;
            });
        });
    
        stopBtn.addEventListener('click', () => {
            if (recorder && recorder.state === 'recording') {
                recorder.stop();
                audioElement.pause();
                startBtn.disabled = false;
                stopBtn.disabled = true;
            }
        });
    
        // Audio File Upload
        audioFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && file.type.startsWith('audio/')) {
                audioElement = new Audio(URL.createObjectURL(file));
                audioElement.controls = true;
                document.body.appendChild(audioElement);
                audioElement.play();
                setupAudioContext(audioElement);
                audioBlob = file;
                prepareAudioDownloadLink(file);
            } else {
                alert("Please upload a valid audio file.");
            }
        });
    </script>
</body>
</html>
