<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AUDIO SPRECTRUM Cr.</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <meta property="og:title" content="AUDIO SPECTRUM Cr.">
    <meta property="og:description" content="Create proffessional audio spectrum's in easy fast and efficient way.">
    <meta property="og:image" content="https://i.ibb.co/5hNwtF5W/AUDIO.png">
    <meta property="og:url" content="https://www.yoursite.com/your-page">
    <meta property="og:type" content="SPECTRUM CREATOR">
    
    <style>
        /* General Styles */
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            color: #333;
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 250px;
            background: #fff;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            overflow-y: auto; /* Allow vertical scrolling */
            height: 100vh; /* Full height */
        }

        .sidebar h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #0073b1;
        }

        .sidebar label {
            display: block;
            margin: 10px 0 5px;
            font-weight: bold;
        }

        .sidebar input[type="color"],
        .sidebar select,
        .sidebar button,
        .sidebar input[type="text"],
        .sidebar input[type="file"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }

        .sidebar button {
            background: #0073b1;
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .sidebar button:hover {
            background: #005f8a;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .main-content h1 {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #0073b1;
        }

        canvas {
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        /* Controls */
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        .controls button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #0073b1;
            color: white;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .controls button:hover {
            background: #005f8a;
        }

        .controls button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Download Link */
        #downloadLink {
            margin-top: 20px;
            padding: 10px 20px;
            background: #0073b1;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            display: none;
        }

        #downloadLink:hover {
            background: #005f8a;
        }

        /* New Download Audio Link */
        #downloadAudioLink {
            margin-top: 20px;
            padding: 10px 20px;
            background: #0073b1;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            display: none;
        }

        #downloadAudioLink:hover {
            background: #005f8a;
        }
    </style>
</head>
<body>
    <!-- Sidebar -->
    <div class="sidebar">
        <button onclick="window.location.href='index.html';" style="background-color: rgb(0, 110, 255); color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">
            BACK
        </button>
                <h2>Settings</h2>

       <!-- Bar Layout -->
<label for="barLayout">Bar Layout</label>
<select id="barLayout">
    <option value="linear">Linear (Horizontal)</option>
    <option value="vertical">Linear (Vertical)</option>
    <option value="circular">Circular</option>
    <option value="center">Center Bars</option>
    <option value="radial">Radial</option>
    <option value="logarithmic">Logarithmic</option>
    <option value="spiral">Spiral</option>
    <option value="gradient">Gradient</option>
    <option value="discrete">Discrete</option>
    <option value="waveform">Waveform</option>
    <option value="branching">Branching</option>
</select>

        <!-- Bar Color -->
        <label for="barColor">Bar Color</label>
        <input type="color" id="barColor" value="#6e44ff">

        <!-- Particle Color -->
        <label for="particleColor">Particle Color</label>
        <input type="color" id="particleColor" value="#ffffff">

        <!-- Particle Effects -->
        <label for="particleToggle">Enable Particles</label>
        <select id="particleToggle">
            <option value="true">Yes</option>
            <option value="false">No</option>
        </select>

        <!-- Background Image -->
        <label for="backgroundImage">Background Image</label>
        <input type="file" id="backgroundImage" accept="image/*">

        <!-- Watermark Position -->
        <label for="watermarkPosition">Watermark Position</label>
        <select id="watermarkPosition">
            <option value="upperleft">Upper Left</option>
            <option value="upperright">Upper Right</option>
            <option value="downleft">Lower Left</option>
            <option value="downright">Lower Right</option>
        </select>

        <!-- Add Text -->
        <label for="textInput">Add Text</label>
        <input type="text" id="textInput" placeholder="Enter text">

        <!-- Font Select -->
        <label for="fontSelect">Font</label>
        <select id="fontSelect">
            <option value="Calibri, sans-serif">Calibri</option>
            <option value="Comfortaa, cursive">Comfortaa</option>
            <option value="Arial, sans-serif">Arial</option>
            <option value="Times New Roman, serif">Times New Roman</option>
            <option value="Courier New, monospace">Courier New</option>
        </select>

        <!-- Text Color -->
        <label for="textColor">Text Color</label>
        <input type="color" id="textColor" value="#ffffff">

        <!-- Upload Logo -->
        <label for="logoUpload">Upload Logo</label>
        <input type="file" id="logoUpload" accept="image/*">

        <!-- Reset Settings -->
        <button id="resetSettings">Reset Settings</button>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <h1>AUDIO SPECTRUM Creator</h1>
        <canvas id="canvas"></canvas>

        <!-- Controls -->
        <div class="controls">
            <input type="file" id="audioFile" accept="audio/*">
            <button id="startRecording">Start Recording</button>
            <button id="stopRecording" disabled>Stop Recording</button>
        </div>

        <!-- Download Links -->
        <a id="downloadLink">Download Video</a>
        <a id="downloadAudioLink">Download Audio</a>
        <p>Made by AUTO ED | @2025 | *subscribe to remove watermark</p>
    </div>

<script>
    const audioFileInput = document.getElementById('audioFile');
    const backgroundImageInput = document.getElementById('backgroundImage');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startRecording');
    const stopBtn = document.getElementById('stopRecording');
    const downloadLink = document.getElementById('downloadLink');
    const downloadAudioLink = document.getElementById('downloadAudioLink');
    const barLayoutSelect = document.getElementById('barLayout');
    const barColorInput = document.getElementById('barColor');
    const particleColorInput = document.getElementById('particleColor');
    const particleToggleSelect = document.getElementById('particleToggle');
    const resetSettingsBtn = document.getElementById('resetSettings');
    const textInput = document.getElementById('textInput');
    const fontSelect = document.getElementById('fontSelect');
    const textColorInput = document.getElementById('textColor');
    const logoUpload = document.getElementById('logoUpload');
    const watermarkPositionSelect = document.getElementById('watermarkPosition');

    // Visible canvas size (fixed for display)
    const displayWidth = 800;
    const displayHeight = 400;
    canvas.width = displayWidth;
    canvas.height = displayHeight;

    // Off-screen canvas for recording
    const offScreenCanvas = document.createElement('canvas');
    const offScreenCtx = offScreenCanvas.getContext('2d');
    let selectedQuality = '720'; // Default quality
    let recordingWidth = 1280; // Default to 720p
    let recordingHeight = 720;
    offScreenCanvas.width = recordingWidth;
    offScreenCanvas.height = recordingHeight;

    let audioContext, analyser, source, dataArray, recorder, chunks = [];
    let backgroundImage = null;
    let particles = [];
    let barLayout = 'linear';
    let barColor = '#6e44ff';
    let particleColor = '#ffffff';
    let enableParticles = true;
    let customText = '';
    let customFont = 'Calibri, sans-serif';
    let customTextColor = '#ffffff';
    let logoImage = null;
    let watermarkPosition = 'upperleft';
    let audioBlob = null;
    let audioElement = null;
    let lastFrameTime = 0;
    const targetFPS = 60; // Increased to 60 FPS
    const frameInterval = 1000 / targetFPS; // ~16.67ms per frame

    // Cached background canvas for performance
    const backgroundCanvas = document.createElement('canvas');
    backgroundCanvas.width = displayWidth;
    backgroundCanvas.height = displayHeight;
    const backgroundCtx = backgroundCanvas.getContext('2d');
    const offScreenBackgroundCanvas = document.createElement('canvas');
    offScreenBackgroundCanvas.width = recordingWidth;
    offScreenBackgroundCanvas.height = recordingHeight;
    const offScreenBackgroundCtx = offScreenBackgroundCanvas.getContext('2d');

    // Event Listeners for Settings
    barLayoutSelect.addEventListener('change', (e) => { barLayout = e.target.value; });
    barColorInput.addEventListener('input', (e) => { barColor = e.target.value; });
    particleColorInput.addEventListener('input', (e) => { particleColor = e.target.value; });
    particleToggleSelect.addEventListener('change', (e) => { enableParticles = e.target.value === 'true'; });
    textInput.addEventListener('input', (e) => { customText = e.target.value; });
    fontSelect.addEventListener('change', (e) => { customFont = e.target.value; });
    textColorInput.addEventListener('input', (e) => { customTextColor = e.target.value; });
    logoUpload.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.src = e.target.result;
                img.onload = function() { logoImage = img; };
            };
            reader.readAsDataURL(file);
        }
    });
    watermarkPositionSelect.addEventListener('change', (e) => { watermarkPosition = e.target.value; });
    resetSettingsBtn.addEventListener('click', () => {
        barLayoutSelect.value = 'linear';
        barColorInput.value = '#6e44ff';
        particleColorInput.value = '#ffffff';
        particleToggleSelect.value = 'true';
        textInput.value = '';
        fontSelect.value = 'Calibri, sans-serif';
        textColorInput.value = '#ffffff';
        logoUpload.value = '';
        watermarkPositionSelect.value = 'upperleft';
        barLayout = 'linear';
        barColor = '#6e44ff';
        particleColor = '#ffffff';
        enableParticles = true;
        customText = '';
        customFont = 'Calibri, sans-serif';
        customTextColor = '#ffffff';
        logoImage = null;
        watermarkPosition = 'upperleft';
    });

    // Handle background image upload with caching
    backgroundImageInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.src = e.target.result;
                img.onload = function() {
                    backgroundImage = img;
                    backgroundCtx.clearRect(0, 0, displayWidth, displayHeight);
                    backgroundCtx.drawImage(img, 0, 0, displayWidth, displayHeight);
                    offScreenBackgroundCtx.clearRect(0, 0, recordingWidth, recordingHeight);
                    offScreenBackgroundCtx.drawImage(img, 0, 0, recordingWidth, recordingHeight);
                };
            };
            reader.readAsDataURL(file);
        }
    });

    // Handle audio file upload with error handling
    audioFileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file && file.type.startsWith('audio/')) {
            audioElement = new Audio();
            audioElement.src = URL.createObjectURL(file);
            audioElement.controls = true;
            document.body.appendChild(audioElement);
            audioElement.play();
            setupAudioContext(audioElement);
            audioBlob = file;
            prepareAudioDownloadLink(file);
        } else {
            alert("Please upload a valid audio file.");
        }
    });

    // Prepare the audio download link
    function prepareAudioDownloadLink(file) {
        const audioURL = URL.createObjectURL(file);
        downloadAudioLink.href = audioURL;
        downloadAudioLink.download = 'audio_file.mp3';
        downloadAudioLink.style.display = 'block';
    }

    // Set up audio context and analyzer
    function setupAudioContext(audio) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 128; // Reduced FFT size for better performance at 60 FPS
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        source = audioContext.createMediaElementSource(audio);
        source.connect(analyser);
        source.connect(audioContext.destination);
        drawVisualizer();
    }

    // Optimized drawVisualizer for 60 FPS
    function drawVisualizer(timestamp) {
        if (!timestamp) timestamp = performance.now();
        if (timestamp - lastFrameTime < frameInterval) {
            requestAnimationFrame(drawVisualizer);
            return; // Skip frame if too soon
        }
        lastFrameTime = timestamp;

        analyser.getByteFrequencyData(dataArray);

        // Clear canvases
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        offScreenCtx.clearRect(0, 0, recordingWidth, recordingHeight);

        // Draw cached background
        if (backgroundImage) {
            ctx.drawImage(backgroundCanvas, 0, 0);
            offScreenCtx.drawImage(offScreenBackgroundCanvas, 0, 0);
        }

        // Calculate bass intensity
        const bassRange = Math.floor(dataArray.length / 3);
        const bassLevel = dataArray.slice(0, bassRange).reduce((a, b) => a + b, 0) / bassRange / 255;
        const shakeIntensity = Math.min(bassLevel * 10, 8); // Reduced max shake for performance
        const vignetteIntensity = Math.min(bassLevel * 0.5, 0.4); // Reduced vignette for 60 FPS
        const offsetX = (Math.random() - 0.5) * shakeIntensity;
        const offsetY = (Math.random() - 0.5) * shakeIntensity;

        // Apply shake to dynamic elements only
        ctx.save();
        ctx.translate(offsetX, offsetY);
        offScreenCtx.save();
        offScreenCtx.translate(offsetX * (recordingWidth / displayWidth), offsetY * (recordingHeight / displayHeight));

        // Draw visual elements based on selected layout
        const drawFunc = {
            'linear': drawLinearBars,
            'vertical': drawVerticalBars,
            'circular': drawCircularBars,
            'center': drawCenterBars,
            'radial': drawRadialBars,
            'logarithmic': drawLogarithmicBars,
            'spiral': drawSpiralBars,
            'gradient': drawGradientBars,
            'discrete': drawDiscreteBars,
            'waveform': drawWaveformBars,
            'branching': drawBranchingBars
        }[barLayout];
        drawFunc(ctx, displayWidth, displayHeight);
        drawFunc(offScreenCtx, recordingWidth, recordingHeight);

        // Draw particles optimized for 60 FPS
        if (enableParticles) {
            drawParticles(ctx, displayWidth, displayHeight, dataArray, bassLevel);
            drawParticles(offScreenCtx, recordingWidth, recordingHeight, dataArray, bassLevel);
        }

        ctx.restore();
        offScreenCtx.restore();

        // Draw vignette after shake
        drawVignette(ctx, displayWidth, displayHeight, vignetteIntensity);
        drawVignette(offScreenCtx, recordingWidth, recordingHeight, vignetteIntensity);

        // Draw static elements without shake
        drawWatermark(ctx, displayWidth, displayHeight);
        drawWatermark(offScreenCtx, recordingWidth, recordingHeight);
        drawCustomTextAndLogo(ctx, displayWidth, displayHeight);
        drawCustomTextAndLogo(offScreenCtx, recordingWidth, recordingHeight);

        requestAnimationFrame(drawVisualizer);
    }

    // Simplified draw functions (no offset parameters since shake is handled in drawVisualizer)
    function drawLinearBars(context, width, height) {
        const barWidth = (width / dataArray.length) * 2.5;
        let x = 0;
        for (let i = 0; i < dataArray.length; i++) {
            const barHeight = dataArray[i] / 2;
            context.fillStyle = barColor;
            context.fillRect(x, height - barHeight, barWidth, barHeight);
            x += barWidth + 1;
        }
    }

    function drawVerticalBars(context, width, height) {
        const barHeight = (height / dataArray.length) * 2.5;
        let y = 0;
        for (let i = 0; i < dataArray.length; i++) {
            const barWidth = dataArray[i] / 2;
            context.fillStyle = barColor;
            context.fillRect(width - barWidth, y, barWidth, barHeight);
            y += barHeight + 1;
        }
    }

    function drawCircularBars(context, width, height) {
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) / 3;
        const angleStep = (Math.PI * 2) / dataArray.length;
        for (let i = 0; i < dataArray.length; i++) {
            const barHeight = dataArray[i] / 2;
            const angle = i * angleStep;
            const x1 = centerX + Math.cos(angle) * radius;
            const y1 = centerY + Math.sin(angle) * radius;
            const x2 = centerX + Math.cos(angle) * (radius + barHeight);
            const y2 = centerY + Math.sin(angle) * (radius + barHeight);
            context.strokeStyle = barColor;
            context.lineWidth = 2;
            context.beginPath();
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            context.stroke();
        }
    }

    function drawCenterBars(context, width, height) {
        const centerX = width / 2;
        const centerY = height / 2;
        const barWidth = (width / dataArray.length) * 2.5;
        let x = centerX - (dataArray.length * barWidth) / 2;
        for (let i = 0; i < dataArray.length; i++) {
            const barHeight = dataArray[i];
            context.fillStyle = barColor;
            context.fillRect(x, centerY - barHeight / 2, barWidth, barHeight);
            x += barWidth + 1;
        }
    }

    function drawRadialBars(context, width, height) {
        const centerX = width / 2;
        const centerY = height / 2;
        const maxRadius = Math.min(width, height) / 2;
        const angleStep = (Math.PI * 2) / dataArray.length;
        for (let i = 0; i < dataArray.length; i++) {
            const value = dataArray[i] / 255;
            const radius = maxRadius * value;
            const angle = i * angleStep;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            context.beginPath();
            context.moveTo(centerX, centerY);
            context.lineTo(x, y);
            context.strokeStyle = barColor;
            context.lineWidth = 2;
            context.stroke();
        }
    }

    function drawLogarithmicBars(context, width, height) {
        const barWidth = width / dataArray.length;
        let x = 0;
        for (let i = 0; i < dataArray.length; i++) {
            const value = Math.log1p(dataArray[i]) * 50;
            context.fillStyle = barColor;
            context.fillRect(x, height - value, barWidth, value);
            x += barWidth + 1;
        }
    }

    function drawSpiralBars(context, width, height) {
        const centerX = width / 2;
        const centerY = height / 2;
        let angle = 0;
        const spiralStep = 0.1;
        const maxRadius = Math.min(width, height) / 2;
        for (let i = 0; i < dataArray.length; i++) {
            const value = dataArray[i] / 255;
            const radius = (i / dataArray.length) * maxRadius * value;
            angle += spiralStep;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            context.beginPath();
            context.arc(x, y, 5, 0, Math.PI * 2);
            context.fillStyle = barColor;
            context.fill();
        }
    }

    function drawGradientBars(context, width, height) {
        const barWidth = width / dataArray.length;
        let x = 0;
        const gradient = context.createLinearGradient(0, height, 0, 0);
        gradient.addColorStop(0, barColor);
        gradient.addColorStop(1, '#ffffff');
        for (let i = 0; i < dataArray.length; i++) {
            const barHeight = dataArray[i];
            context.fillStyle = gradient;
            context.fillRect(x, height - barHeight, barWidth, barHeight);
            x += barWidth + 1;
        }
    }

    function drawDiscreteBars(context, width, height) {
        const barWidth = width / dataArray.length;
        let x = 0;
        for (let i = 0; i < dataArray.length; i++) {
            const value = Math.floor(dataArray[i] / 51) * 51;
            context.fillStyle = barColor;
            context.fillRect(x, height - value, barWidth, value);
            x += barWidth + 1;
        }
    }

    function drawWaveformBars(context, width, height) {
        context.beginPath();
        const barWidth = width / dataArray.length;
        let x = 0;
        context.moveTo(0, height / 2);
        for (let i = 0; i < dataArray.length; i++) {
            const value = (dataArray[i] - 128) / 128 * (height / 4);
            context.lineTo(x, height / 2 + value);
            x += barWidth;
        }
        context.strokeStyle = barColor;
        context.lineWidth = 2;
        context.stroke();
    }

    function drawBranchingBars(context, width, height) {
        const centerX = width / 2;
        const centerY = height;
        const angleStep = Math.PI / (dataArray.length - 1);
        for (let i = 0; i < dataArray.length; i++) {
            const value = dataArray[i] / 255 * height / 2;
            const angle = -Math.PI / 2 + i * angleStep;
            const x = centerX + Math.cos(angle) * value;
            const y = centerY + Math.sin(angle) * value;
            context.beginPath();
            context.moveTo(centerX, centerY);
            context.lineTo(x, y);
            context.strokeStyle = barColor;
            context.lineWidth = 2;
            context.stroke();
        }
    }

    // Optimized particle system for 60 FPS
    function drawParticles(context, width, height, frequencyData, bassLevel) {
        const particleCount = Math.min(Math.floor(bassLevel * 10) + Math.floor(frequencyData.reduce((a, b) => a + b, 0) / frequencyData.length / 100), 20); // Cap at 20 particles per frame
        for (let i = 0; i < particleCount; i++) {
            const freqIndex = Math.floor(Math.random() * frequencyData.length);
            const intensity = frequencyData[freqIndex] / 255;
            if (intensity > 0.4) { // Higher threshold for performance
                const x = (freqIndex / frequencyData.length) * width;
                const y = height * (1 - intensity);
                particles.push(new Particle(
                    x,
                    y,
                    Math.random() * 2 + 1,
                    particleColor,
                    { x: (Math.random() - 0.5) * 1.5, y: -intensity * 1.5 }
                ));
            }
        }
        particles = particles.filter(p => p.alpha > 0).slice(-50); // Limit total particles to 50
        particles.forEach(p => p.update(context));
    }

    // Vignette effect optimized for 60 FPS
    function drawVignette(context, width, height, intensity) {
        const gradient = context.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, Math.max(width, height) / 2);
        gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
        gradient.addColorStop(1, `rgba(0, 0, 0, ${intensity})`);
        context.fillStyle = gradient;
        context.fillRect(0, 0, width, height);
    }

    function drawWatermark(context, width, height) {
        context.font = 'bold 24px "Segoe UI", Arial, sans-serif';
        const padding = 10;
        let x, y;
        switch (watermarkPosition) {
            case 'upperleft': x = padding; y = padding + 24; break;
            case 'upperright': x = width - context.measureText('AUTO ED').width - padding; y = padding + 24; break;
            case 'downleft': x = padding; y = height - padding; break;
            case 'downright': x = width - context.measureText('AUTO ED').width - padding; y = height - padding; break;
        }
        context.fillStyle = '#ffffff';
        context.fillText('AUTO', x, y);
        const autoWidth = context.measureText('AUTO ').width;
        context.fillStyle = '#ff0000';
        context.fillText('ED', x + autoWidth, y);
    }

    function drawCustomTextAndLogo(context, width, height) {
        if (customText || logoImage) {
            context.save();
            context.translate(width / 2, height / 2);
            if (logoImage) {
                const logoSize = 100;
                context.drawImage(logoImage, -logoSize / 2, -logoSize / 2 - 50, logoSize, logoSize);
            }
            if (customText) {
                context.font = `24px ${customFont}`;
                context.fillStyle = customTextColor;
                context.textAlign = 'center';
                context.fillText(customText, 0, 30);
            }
            context.restore();
        }
    }

    class Particle {
        constructor(x, y, radius, color, velocity) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
            this.velocity = velocity;
            this.alpha = 1;
        }
        draw(context) {
            context.save();
            context.globalAlpha = this.alpha;
            context.beginPath();
            context.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
            context.fillStyle = this.color;
            context.fill();
            context.restore();
        }
        update(context) {
            this.draw(context);
            this.x += this.velocity.x;
            this.y += this.velocity.y;
            this.alpha -= 0.02; // Faster fade for 60 FPS
        }
    }

    // Set recording resolution based on quality
    function setRecordingResolution(quality) {
        const resolutionMap = {
            '1080': { width: 1920, height: 1080 },
            '720': { width: 1280, height: 720 },
            '360': { width: 640, height: 360 },
            '240': { width: 426, height: 240 },
            '140': { width: 256, height: 144 }
        };
        const { width, height } = resolutionMap[quality] || resolutionMap['720'];
        offScreenCanvas.width = width;
        offScreenCanvas.height = height;
        offScreenBackgroundCanvas.width = width;
        offScreenBackgroundCanvas.height = height;
        recordingWidth = width;
        recordingHeight = height;
        if (backgroundImage) {
            offScreenBackgroundCtx.clearRect(0, 0, recordingWidth, recordingHeight);
            offScreenBackgroundCtx.drawImage(backgroundImage, 0, 0, recordingWidth, recordingHeight);
        }
    }

    // Show quality selection popup before recording
    function showQualityPopupBeforeRecording(callback) {
        const popup = document.createElement('div');
        popup.style.position = 'fixed';
        popup.style.top = '50%';
        popup.style.left = '50%';
        popup.style.transform = 'translate(-50%, -50%)';
        popup.style.background = '#fff';
        popup.style.padding = '20px';
        popup.style.borderRadius = '10px';
        popup.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.2)';
        popup.style.zIndex = '1000';

        popup.innerHTML = `
            <h3>Select Video Quality</h3>
            <button data-quality="1080" style="display: block; width: 100%; margin: 5px 0; padding: 10px; background: #0073b1; color: white; border: none; border-radius: 5px; cursor: pointer;">1080HD</button>
            <button data-quality="720" style="display: block; width: 100%; margin: 5px 0; padding: 10px; background: #0073b1; color: white; border: none; border-radius: 5px; cursor: pointer;">720p</button>
            <button data-quality="360" style="display: block; width: 100%; margin: 5px 0; padding: 10px; background: #0073b1; color: white; border: none; border-radius: 5px; cursor: pointer;">360p</button>
            <button data-quality="240" style="display: block; width: 100%; margin: 5px 0; padding: 10px; background: #0073b1; color: white; border: none; border-radius: 5px; cursor: pointer;">240p</button>
            <button data-quality="140" style="display: block; width: 100%; margin: 5px 0; padding: 10px; background: #0073b1; color: white; border: none; border-radius: 5px; cursor: pointer;">140p</button>
        `;

        document.body.appendChild(popup);

        popup.querySelectorAll('button').forEach(button => {
            button.addEventListener('click', () => {
                selectedQuality = button.getAttribute('data-quality');
                setRecordingResolution(selectedQuality);
                document.body.removeChild(popup);
                callback();
            });
        });
    }

    // Handle recording with 60 FPS settings
    startBtn.addEventListener('click', function () {
        if (!audioElement) {
            alert("Please upload an audio file first.");
            return;
        }
        showQualityPopupBeforeRecording(() => {
            chunks = [];
            const stream = offScreenCanvas.captureStream(targetFPS); // 60 FPS
            const audioStream = audioElement.captureStream();
            const combinedStream = new MediaStream([...stream.getVideoTracks(), ...audioStream.getAudioTracks()]);
            recorder = new MediaRecorder(combinedStream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 4000000 // Increased bitrate for 60 FPS quality
            });

            recorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    chunks.push(e.data);
                }
            };

            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                downloadLink.href = url;
                downloadLink.download = `audio_visualization_${selectedQuality}p_60fps.webm`;
                downloadLink.style.display = 'block';
                chunks = []; // Clear chunks to free memory
            };

            audioElement.currentTime = 0; // Restart audio for recording
            audioElement.play();
            recorder.start(50); // Reduced timeslice to 50ms for smoother 60 FPS chunks
            startBtn.disabled = true;
            stopBtn.disabled = false;
        });
    });

    stopBtn.addEventListener('click', function () {
        if (recorder && recorder.state === 'recording') {
            recorder.stop();
            audioElement.pause();
            startBtn.disabled = false;
            stopBtn.disabled = true;
        }
    });
</script>
</body>
</html>
